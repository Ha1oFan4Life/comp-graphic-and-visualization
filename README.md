# comp-graphic-and-visualization
How Do I Approach Designing Software?
My approach to designing software starts with understanding the problem, planning structure, and focusing on modularity. For this project, I began by studying my real workspace and breaking it down into fundamental geometric primitives that could be represented efficiently in OpenGL. This process mirrored how I would approach larger software projects: by analyzing the system, decomposing it into manageable components, and iterating toward refinement.

Design Skills Developed
Through this project, I strengthened my ability to design within constraints balancing realism, performance, and simplicity. I learned to think spatially and mathematically about how objects interact in three-dimensional space, which deepened my understanding of transformations, coordinate systems, and lighting design. I also refined my sense of visual composition and environmental coherence, which are important design considerations in both software interfaces and 3D rendering.

Design Process Followed
I followed an iterative design process:
Conceptualization — choosing my real workspace as a relatable subject.
Modeling — breaking complex shapes into simple geometric primitives.
Texturing and Lighting — experimenting with materials and Phong lighting to achieve the desired aesthetic.
Testing and Refinement — adjusting light placement, object scaling, and camera controls based on visual results.

Future Application of Design Tactics
The design process I used here incremental prototyping, visual testing, and modular structure applies broadly to future projects. Whether building an interactive simulation, a game, or a web-based tool, breaking the problem into core elements and iterating through functional and visual design cycles ensures scalability and maintainability.

How Do I Approach Developing Programs?
I approach development as an iterative and structured process, emphasizing clarity, testing, and modularization. In this project, I treated each 3D object like an independent class or module, encapsulated within functions such as drawMonitor(), drawConsole(), and drawKeyboard(). This modular approach made it easier to isolate issues and adjust individual models without breaking the whole scene.

Development Strategies Used
Working on this 3D scene required me to use new strategies for organization and testing. I leveraged incremental builds to verify rendering performance, applied lighting iteratively to fine-tune realism, and separated input-handling logic from rendering logic for cleaner control flow. I also utilized parameterization to adjust object scales and lighting intensity efficiently.

Role of Iteration
Iteration was a key part of development — especially in calibrating camera controls and lighting. Each iteration improved visual balance and interaction smoothness, reinforcing how small refinements accumulate into polished outcomes. Iteration also helped maintain performance by allowing me to test polygon counts and lighting combinations without overloading the GPU.

Evolution of My Coding Approach
Throughout the milestones, my approach evolved from writing straightforward procedural code to thinking more modularly and conceptually. I gained a better sense of how to structure programs for readability and long-term maintainability, applying software engineering principles like separation of concerns, abstraction, and naming consistency to a graphics context.

How Can Computer Science Help Me in Reaching My Goals?
Computer science empowers me to create visual and interactive experiences that merge logic with creativity. This project, in particular, showed me how computational graphics can transform data and abstract logic into tangible, expressive outputs.

Educational Pathway
Computational graphics has deepened my understanding of mathematical models, linear algebra, and spatial reasoning all essential for higher-level computer science courses and specialized fields like AI visualization, simulation systems, or human-computer interaction. The project enhanced my ability to connect theory with application through hands-on 3D problem-solving.

Professional Pathway
Professionally, the skills I developed here translate directly into software design, visualization, and user experience development. Understanding how to build interactive environments and simulate real-world conditions is valuable for careers in software engineering, game development, AR/VR, and digital visualization. The discipline required to plan, structure, and refine a 3D application mirrors the process of developing efficient, scalable software systems a skill I’ll continue to carry forward in my career.
